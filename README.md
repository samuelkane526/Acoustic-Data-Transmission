Acoustic-Data-Transmission
This C program uses different frequencies of sound encoder with __encoder.c__ to transfer data wirelessly over short distances.

Getting Started:
To ensure a successful transfer, you must follow this specific order of operations, as the Encoder depends on values generated by the Decoder's hardware calibration. Keep in mind that for best results you must follow these instructions closely.

1. Initialize the Decoder (The Listener)
Run __decoder.exe__ on the receiving computer.

Upon startup, the decoder will calibrate based on your hardware's sample rate and display a configuration block.

Copy the values displayed under the header: --- COPY/PASTE THIS INTO YOUR ENCODER .INI FILE ---.

2. Configure and Run the Encoder (The Speaker)
Place the file you want to transmit (e.g., __test.txt__) in the same folder as __encoder.exe__.

Open __encoder_config.ini__.

Update the Frequencies: Paste the values you copied from the decoder into the [Frequencies] and [Audio] sections.

Set Input: Find the line InputFile= and change it to your filename (e.g., InputFile=test.txt).

Save the file and run __encoder.exe__. This creates the __transmit.wav__.

3. Perform the Transmission
Ensure the Decoder is still running and says MONITORING.

Play __transmit.wav__ through your speakers.

Using two separate devices is highly recommended. Playing and recording on the same machine often causes internal feedback loop interference.

The decoder will show a progress bar and the values of recieved bytes in hex format (e.g., [41][42][0D]).

Once the "Terminator" signal is heard, the file will be saved automatically to the decoder's directory.

The How (Decoder):
This program acts as a Frequency-Shift Keying Receiver (FSK). It converts sound data (time domain voltage signals), into frequency-domain voltage specteral data to identify patterns that corospond to different bytes.

My program takes in chunks of data (blocks), with each block having ___FFT_SIZE___ total samples (defualt 4096). The script finds the most dominate frequency in the block. The higher the ___FFT_FRAMES___ per block, the higher the accuracy, the more unique bytes packable into a frequency range, with a trade off of processing speed.

The standard sample rate of most onboard microphones is 48,000hz. If we are getting 48,000 samples per second, we can fill up our ___FFT_FRAMES___ in 48,000hz/___FFT_SIZE___ ms. In this case it is 48,000hz/4096 = 11.71hz. 11.71hz is now our frequency range, or our ___BIN_SPACING___.

Using the ___BIN_SPACING___ value we already got, we assign uniuqe values each BIN_SPACING*2 apart. Our ___BASE_FREQUENCY___ is 1000hz, so our first data signal is assigned to 1000hz, and our second 1023.43hz. There are 259 total signals we need to repersent, meaning we go up to 6976hz with the defualt values.

Signal Types:
HELLO: Tells the program to start analyzing audio. (bin_width*26)

HEADER: Tells the program to start treating next data as header data. (Defualt 800hz)

Terminator: Tells program transmission is finished. (Default 8000hz)

Our sample size is a continious stream of data, our ___FFT_FRAMES___ is the area we have loaded into memory, and the ___STEP_SIZE___ is the amount we step ___FFT_FRAMES___ forward. This means the lower the ___STEP_SIZE___ the more times each data section will be analyzed.

Any disturbances in the room like fans, tvs, voices or even the echo of the programs signals can interfere with the program. ___THRESHOLD___ tells our program to ignore all frequencies under the amplitude of its value. You can fine tune this with __calibrate.c__. The larger and less padded the room is, the higher the required threshold.

The final part to our program in the ___DEBOUNCE___. The ___DEBOUNCE___ is the number of framtes in FFT that is checked before it decides on a signal. The higher the ___DEBOUNCE___ the higher the accuracy. However, this means you will need to play the audio at a slower speed. (0 = one check)

That is all of the technical details behind the audio transmission!
