# Acoustic-Data-Transmission
This C program uses data encoded into sound with the encoder script, and sends them from a capturing device running decoder.c. Decoder is able to read the audio data and save it as any type of file. While similar systems of acoustic data transmission where used in the past such as for modem landline phones, I have yet to think of a practical application for this. However, there is a lot to learn from this project and its many small optimzations! I hope you find this as cool as I did!!

# Prerequisites (IMPORTANT - READ THIS)
  #1 You MUST disable audio enchancments for windows. If you do not, the audio is stripped of frequencies past 8000hz, and you will lose most of your data. In your settings go to _system/sound/_ then _input>microphone array_ then _audio enhancements_ _off_.
  #2 If your enviorment is to loud this likely will not work. Check what your threshold is set as at the bottom of your terminal. If it is high (e.g 20+) consider switching     to a different smaller more padded room. Overall, just attempt to minimize all noise to zero. You can also simply play the transmission louder, but your ears would most       likely prefer other options. 
  #3 Ensure your speaker and your mic are both of some quality. This is of little concern, as most modern laptops have perfectly capable mics, as the same for speakers.         However, if using extremely old or cheap software, keep this in mine.
  #4 Keep in mind the speaker and mic must be with in 1 or 2 feet of each other. The closer the better. For longer ranges, considering directional speakers, louder volumes,      smaller rooms, and padded walls to reduce chance of echo interference. 
  

# Getting Started:
  To ensure a successful transfer, you must follow this specific order of operations, as the Encoder depends on values generated by the Decoder's hardware calibration. Keep in mind that for best results you must follow these instructions closely.

# 1. Initialize the Decoder (The Listener)
  Run __decoder.exe__ on the receiving computer.
  
  Upon startup, the decoder will calibrate based on your hardware's sample rate and display a configuration block.
  
  Copy the values displayed under the header: --- COPY/PASTE THIS INTO YOUR ENCODER .INI FILE ---.
  
  # 2. Configure and Run the Encoder (The Speaker)
  Place the file you want to transmit (e.g., __test.txt__) in the same folder as __encoder.exe__.
  
  Open __encoder_config.ini__.
  
  Update the Frequencies: Paste the values you copied from the decoder into the [Frequencies] and [Audio] sections.
  
  Set Input: Find the line InputFile= and change it to your filename (e.g., InputFile=test.txt).
  
  Save the file and run __encoder.exe__. This creates the __transmit.wav__.

# 3. Perform the Transmission
  Ensure the Decoder is still running and says MONITORING.
  
  Play __transmit.wav__ through your speakers.
  
  Using two separate devices is highly recommended. Playing and recording on the same machine often causes internal feedback loop interference.
  
  The decoder will show a progress bar and the values of recieved bytes in hex format (e.g., [41][42][0D]).
  
  Once the "Terminator" signal is heard, the file will be saved automatically to the decoder's directory.


# The How (Decoder):
  This program acts as a Frequency-Shift Keying Receiver (FSK). It converts sound data (time domain voltage signals), into frequency-domain voltage spectral data to identify patterns that correspond to different bytes.
  
  My program takes in chunks of data (blocks), with each block having ___FFT_SIZE___ total samples (default 2048). The script finds the most dominant frequency in the block. The higher the ___FFT_SIZE___, the higher the accuracy and the more unique bytes we can pack into a frequency range, but it comes with a trade-off in processing speed.
  
  The standard sample rate of most onboard microphones is 48,000Hz. If we are getting 48,000 samples per second, we can calculate our frequency resolution, or ___BIN_WIDTH___, using this formula:
  
  BIN_WIDTH= 
  FFT_SIZE
  Sample Rate
  â€‹
   
  In this case, it is 48,000/2,048=23.44Hz. This 23.44Hz is now our frequency range for each "slot" in the FFT.
  
  Frequency Mapping and Spacing:
  Using the ___BIN_WIDTH___ value, the program automatically calculates where signals should live to prevent "spectral leakage" (where sound smears into nearby bins). With ___AUTO_SPACING___ enabled, we assign unique values each ___BIN_WIDTH * 2___ apart.
  
  Our ___BASE_FREQ___ starts at ___BIN_WIDTH * 52___ (approx 1218Hz), and we go up from there. There are 257 total signals we represent (0-255 for data, and 256 for a "Repeat" signal), meaning we go up to about 7200Hz with the default values.
  
  The Repeat Signal (___REPEAT_IDX___): If the encoder needs to send the same byte twice (like "AA"), it switches to frequency 256. This tells the decoder to just repeat the last byte it saw, preventing the signals from blending together.
  
  Signal Types:
  HELLO: Tells the program to start analyzing audio. (___BIN_WIDTH * 26___)
  
  HEADER: Tells the program to start treating next data as a ___ChordHeader___ struct. (___BIN_WIDTH * 36___)
  
  Terminator: Tells program transmission is finished and it's time to save the file. (___BIN_WIDTH * 588___)
  
  Analysis and Stability:
  Our sample size is a continuous stream of data. ___FFT_SIZE___ is the area we have loaded into memory, and the ___STEP_SIZE___ is the amount we move forward through that stream. The lower the ___STEP_SIZE___, the more times each data section is analyzed, which helps catch signals faster.
  
  Any disturbances in the room like fans, TVs, or voices can interfere. ___THRESHOLD___ tells our program to ignore all frequencies under a certain amplitude. You can fine-tune this in ___decoder_config.ini___.
  
  The final part is the ___DEBOUNCE_LIMIT___. This is the number of consecutive FFT frames a frequency must stay stable in before the program decides it's a real signal. The higher the limit, the higher the accuracy, but you'll need to play the audio slower to give the decoder time to "lock on."
  
  Data Integrity (Sync and Checksum):
  To make sure the file isn't corrupted by a sneeze or a door slam, the program uses two checks:
  
  Sync Marker: Every transmission must start with the byte ___0xFE___. If the decoder doesn't see this first, it ignores the data.
  
  Checksum: The ___ChordHeader___ contains a math total of all the bytes in the file. Once the Terminator is heard, the decoder adds up everything it received. If the numbers don't match, it warns you about a Checksum Mismatch.
  
  That is all of the technical details behind the audio transmission!
