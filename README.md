# Acoustic-Data-Transmission
This C program uses data encoded into sound with the encoder script, and sends them from a capturing device running decoder.c. Decoder is able to read the audio data and save it as any type of file. While similar systems of acoustic data transmission where used in the past such as for modem landline phones, I have yet to think of a practical application for this. However, there is a lot to learn from this project and its many small optimzations! I hope you find this as cool as I did!!

# Prerequisites (IMPORTANT - READ THIS)
  #1 You MUST disable audio enchancments for windows. If you do not, the audio is stripped of frequencies past 8000hz, and you will lose most of your data. In your settings go to _system/sound/_ then _input>microphone array_ then _audio enhancements_ _off_.
  #2 If your enviorment is to loud this likely will not work. Check what your threshold is set as at the bottom of your terminal. If it is high (e.g 20+) consider switching     to a different smaller more padded room. Overall, just attempt to minimize all noise to zero. You can also simply play the transmission louder, but your ears would most       likely prefer other options. 
  #3 Ensure your speaker and your mic are both of some quality. This is of little concern, as most modern laptops have perfectly capable mics, as the same for speakers.         However, if using extremely old or cheap software, keep this in mine.
  #4 Keep in mind the speaker and mic must be with in 1 or 2 feet of each other. The closer the better. For longer ranges, considering directional speakers, louder volumes,      smaller rooms, and padded walls to reduce chance of echo interference. 
  

# Getting Started:
  To ensure a successful transfer, you must follow this specific order of operations, as the Encoder depends on values generated by the Decoder's hardware calibration. Keep in mind that for best results you must follow these instructions closely.

# 1. Initialize the Decoder (The Listener)
  Run __ChordCastDecoder.exe__ on the receiving computer.
  
  Upon startup, the decoder will calibrate based on your hardware's sample rate and display a configuration block.
  
  Copy the values displayed under the header: --- COPY/PASTE THIS INTO YOUR ENCODER .INI FILE ---.
  
  # 2. Configure and Run the Encoder (The Speaker)
  Place the file you want to transmit (e.g., __test.txt__) in the same folder as __ChordCastEncoder.exe__.
  
  Open __encoder_config.ini__.
  
  Update the Frequencies: Paste the values you copied from the decoder into the [Frequencies] and [Audio] sections.
  
  Set Input: Find the line InputFile= and change it to your filename (e.g., InputFile=test.txt).
  
  Save the file and run __ChordCastEncoder.exe__. This creates the __transmit.wav__.

# 3. Perform the Transmission
  Ensure the Decoder is still running and says MONITORING.
  
  Play __transmit.wav__ through your speakers.
  
  Using two separate devices is highly recommended. Playing and recording on the same machine often causes internal feedback loop interference.
  
  The decoder will show a progress bar and the values of recieved bytes in hex format (e.g., [41][42][0D]).
  
  Once the "Terminator" signal is heard, the file will be saved automatically to the decoder's directory.


# Data Transfer Issues and Fixes
  This section covers common issues when transmitting files. Since this protocol relies on physical sound waves, your environment (room acoustics) and volume levels are the most critical factors.
  
  # 1. Nothing is showing up (No Handshake/Headers)
  The Issue: The decoder remains in STATE_IDLE and never detects the HELLO or HEADER signals.
  
  The Fix:
  
  Check Input Device: Ensure the correct microphone is set as the Default Recording Device in Windows Sound Settings. The program automatically grabs the default device on startup.
  
  Volume is too low: The signal strength (Mag) is staying below the THRESHOLD. Turn up your source volume.
  
  Threshold is too high: If AutoThreshold=0 in your .ini file, try lowering the manual Threshold value (e.g., from 5.0 to 2.0). If AutoThreshold is zero it will ignore your   manual threshold value.
  
  # Sample Rate Mismatch: 
  Ensure both the Encoder and Decoder are operating on the same sample rate (usually 48000Hz). If the Decoder expects 48kHz but the mic provides         44.1kHz, the math     for BIN_WIDTH will be wrong, and it will look for frequencies in the wrong place.
  
  # 2. Bytes are being read, but they are all wrong (Garbage Data)
  The Issue: You see data scrolling in the terminal, but the file is corrupted or the checksum fails.
  
  The Fix:
  
  Clipping (Distortion): If the volume is too high, the microphone input clips (flatlines), creating "harmonics" (ghost frequencies). This causes the decoder to see           frequencies that aren't actually there. Turn the volume down to about 70-80%.
  
  Background Noise: Loud fans, mechanical keyboards, or voices can introduce random frequencies. Enable AutoThreshold=1 or move to a quieter environment.
  
  Reverb/Echo: In large empty rooms, the "echo" of the previous byte might overlap with the current one. Move the microphone closer to the speaker (direct line of sight) to overpower the echoes.
  
  # 3. Transmission starts, but "drops" bytes (Incomplete Data)
  The Issue: The transmission finishes, but you get the error: Transmission Failed: Incomplete Data.
  
  The Fix:
  
  Debounce Limit vs. Speed: The DebounceLimit might be too high for the speed of the transmission. The decoder is waiting too long to confirm a note, and the note ends before it is accepted.
  
  Solution: Lower DebounceLimit in decoder_config.ini (e.g., from 6 to 4).
  
  Transmission Speed: The encoder might be playing too fast. Increase the DURATION (note length) in the encoder to give the decoder more time to "catch" each byte.
  
  Signal "Dip": Laptop speakers often struggle with specific low frequencies. If you consistently lose specific bytes, try increasing the BaseFreq to move the transmission into a higher range that your speakers can handle better.
  
  # 4. "Checksum Mismatch" Error
  The Issue: You received the correct number of bytes (Size matches), but the math doesn't add up.
  
  The Fix:
  
  This is usually a Bit Flip. One specific frequency was misread as its neighbor (e.g., 1218Hz read as 1265Hz).
  
  AutoSpacing: Ensure AutoSpacing=1 is enabled. If you manually tuned frequencies, your BIN_SPACING might be too narrow, causing "Spectral Leakage" where one bin bleeds into another.
  
  Stability: Increase DebounceLimit (e.g., from 4 to 6) to force the decoder to be more certain before accepting a byte.


# The How (Encoder):
  _Compile: gcc encoder.c -o ChordCastEncoder.exe -lm -static -static-libgcc_

  The encoder is the "voice" of the program. It takes raw files (text, images, or small binaries) and converts them into a sequence of acoustic tones. These tones are then saved into a standard 16-bit PCM .wav file for playback.
  
  # The Transmission Process:
  Handshake (FREQ_HELLO): The encoder starts by playing a long "Hello" tone. This alerts the decoder that a transmission is about to begin.
  
  Metadata (FREQ_HEADER): Before the file data starts, the encoder plays a "Header" tone. Immediately following this, it transmits a ___ChordHeader___ struct which contains:
  
  Filename: So the decoder knows what to name the file.
  
  FileSize: So the decoder knows when to stop listening.
  
  Checksum: A sum calculated from the size of the transmission. It is sent at the start and if the final size of the transmission does not equal it, the program knows it      missed data.
  
  Data Payload: The file is broken down byte-by-byte. Each byte (0-255) is mapped to a specific frequency based on the ___BASE_FREQ___ and ___BIN_SPACING___.
  
  Termination (FREQ_TERM): Once the last byte is sent, the encoder plays three rapid "Terminator" bursts. This tells the decoder to run checksum and close the file. We use    three to ensure the decoder hears it, as the high frequency can lead to rare errors.
  
  Signal Generation and Smoothing:
  To ensure the audio is clean and doesn't damage speakers or hurt ears with "pops" and "clicks," the encoder uses two specific techniques:
  
  Anti-Pop Fading: At the start and end of every single tone, the encoder applies a 5ms "Fade-In" and "Fade-Out." This smooths the transition from silence to sound.
  
  The Repeater Logic (REPEAT_IDX): If the encoder needs to send the same byte twice (e.g., the letters "oo" in "room"), playing the same frequency continuously would look     like one long single note to the decoder. To fix this, the encoder switches the second "o" to a special Repeater Frequency. This creates a visible "break" for the decoder   to count the second byte correctly. It is also less harsh on the ears.
  
  Timing and Durations:
  The timing is controlled by the ___DataDur___ and ___ByteGap___ settings in ___encoder_config.ini___.
  
  ___DataDur___: How long each frequency is played.
  
  ___ByteGap___: A short period of silence between tones to allow the room echoes to die down before the next byte starts.
  
  WAV Structure:
  The encoder generates a Mono, 16-bit PCM wave file. It manually constructs the RIFF header, ensuring the ___overall_size___ and ___data_size___ are accurately calculated    so that any standard media player can play the transmission.

# The How (Decoder):
  _Compile: gcc decoder.c kissfft-131.2.0/kiss_fft.c -o ChordCastDecoder.exe -lole32 -lwinmm -static -static-libgcc -I./kissfft-131.2.0_

  This program acts as a Frequency-Shift Keying Receiver (FSK). It converts sound data (time domain voltage signals), into frequency-domain voltage spectral data to identify patterns that correspond to different bytes.
  
  My program takes in chunks of data (blocks), with each block having ___FFT_SIZE___ total samples (default 2048). The script finds the most dominant frequency in the block. The higher the ___FFT_SIZE___, the higher the accuracy and the more unique bytes we can pack into a frequency range, but it comes with a trade-off in processing speed.
  
  The standard sample rate of most onboard microphones is 48,000Hz. If we are getting 48,000 samples per second, we can calculate our frequency resolution, or ___BIN_WIDTH___, using this formula:
  
  BIN_WIDTH= 
  FFT_SIZE
  Sample Rate
  â€‹
   
  In this case, it is 48,000/2,048=23.44Hz. This 23.44Hz is now our frequency range for each "slot" in the FFT.
  
  Frequency Mapping and Spacing:
  Using the ___BIN_WIDTH___ value, the program automatically calculates where signals should live to prevent "spectral leakage" (where sound smears into nearby bins). With ___AUTO_SPACING___ enabled, we assign unique values each ___BIN_WIDTH * 2___ apart.
  
  Our ___BASE_FREQ___ starts at ___BIN_WIDTH * 52___ (approx 1218Hz), and we go up from there. There are 257 total signals we represent (0-255 for data, and 256 for a "Repeat" signal), meaning we go up to about 7200Hz with the default values.
  
  The Repeat Signal (___REPEAT_IDX___): If the encoder needs to send the same byte twice (like "AA"), it switches to frequency 256. This tells the decoder to just repeat the last byte it saw, preventing the signals from blending together.
  
  Signal Types:
  HELLO: Tells the program to start analyzing audio. (___BIN_WIDTH * 26___)
  
  HEADER: Tells the program to start treating next data as a ___ChordHeader___ struct. (___BIN_WIDTH * 36___)
  
  Terminator: Tells program transmission is finished and it's time to save the file. (___BIN_WIDTH * 588___)
  
  Analysis and Stability:
  Our sample size is a continuous stream of data. ___FFT_SIZE___ is the area we have loaded into memory, and the ___STEP_SIZE___ is the amount we move forward through that stream. The lower the ___STEP_SIZE___, the more times each data section is analyzed, which helps catch signals faster.
  
  Any disturbances in the room like fans, TVs, or voices can interfere. ___THRESHOLD___ tells our program to ignore all frequencies under a certain amplitude. You can fine-tune this in ___decoder_config.ini___.
  
  The final part is the ___DEBOUNCE_LIMIT___. This is the number of consecutive FFT frames a frequency must stay stable in before the program decides it's a real signal. The higher the limit, the higher the accuracy, but you'll need to play the audio slower to give the decoder time to "lock on."
  
  Data Integrity (Sync and Checksum):
  To make sure the file isn't corrupted by a sneeze or a door slam, the program uses two checks:
  
  Sync Marker: Every transmission must start with the byte ___0xFE___. If the decoder doesn't see this first, it ignores the data.
  
  Checksum: The ___ChordHeader___ contains a math total of all the bytes in the file. Once the Terminator is heard, the decoder adds up everything it received. If the numbers don't match, it warns you about a Checksum Mismatch.
  
  That is all of the technical details behind the audio transmission!
